// ===== „Ç∞„É©„Éï„ÉªÁµ±Ë®à„É¢„Ç∏„É•„Éº„É´ =====
const ChartsModule = {
    charts: {},
    colors: {
        primary: 'rgba(102, 126, 234, 1)',
        primaryLight: 'rgba(102, 126, 234, 0.5)',
        secondary: 'rgba(118, 75, 162, 1)',
        success: 'rgba(76, 175, 80, 1)',
        warning: 'rgba(255, 152, 0, 1)',
        error: 'rgba(244, 67, 54, 1)',
        gradient: {
            primary: ['rgba(102, 126, 234, 0.8)', 'rgba(118, 75, 162, 0.8)'],
            success: ['rgba(76, 175, 80, 0.8)', 'rgba(139, 195, 74, 0.8)'],
            warm: ['rgba(255, 111, 0, 0.8)', 'rgba(255, 152, 0, 0.8)']
        }
    },
    
    // ÂàùÊúüÂåñ
    initialize() {
        this.initializeWeekChart();
        this.initializeSubjectChart();
        this.initializeMonthlyChart();
        this.initializeTrendChart();
        
        console.log('üìä „Ç∞„É©„Éï„É¢„Ç∏„É•„Éº„É´ÂàùÊúüÂåñÂÆå‰∫Ü');
    },
    
    // ÈÄ±ÈñìÂ≠¶Áøí„Ç∞„É©„Éï
    initializeWeekChart() {
        const ctx = document.getElementById('weekChart');
        if (!ctx) return;
        
        this.charts.week = new Chart(ctx.getContext('2d'), {
            type: 'bar',
            data: {
                labels: ['Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü', 'Êó•'],
                datasets: [{
                    label: 'Â≠¶ÁøíÂïèÈ°åÊï∞',
                    data: [0, 0, 0, 0, 0, 0, 0],
                    backgroundColor: this.colors.primaryLight,
                    borderColor: this.colors.primary,
                    borderWidth: 2,
                    borderRadius: 8,
                    borderSkipped: false,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        cornerRadius: 8,
                        callbacks: {
                            label: (context) => `${context.parsed.y}ÂïèËß£Á≠î`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0,0,0,0.1)'
                        },
                        ticks: {
                            stepSize: 10
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    },
    
    // ÁßëÁõÆÂà•„É¨„Éº„ÉÄ„Éº„ÉÅ„É£„Éº„Éà
    initializeSubjectChart() {
        const ctx = document.getElementById('subjectChart');
        if (!ctx) return;
        
        this.charts.subject = new Chart(ctx.getContext('2d'), {
            type: 'radar',
            data: {
                labels: ['Ê∞ëÊ≥ï', 'Ë°åÊîøÊ≥ï', 'ÊÜ≤Ê≥ï', 'ÂïÜÊ≥ï', 'Âü∫Á§éÊ≥ïÂ≠¶', '‰∏ÄËà¨Áü•Ë≠ò'],
                datasets: [{
                    label: 'Ê≠£Á≠îÁéá',
                    data: [0, 0, 0, 0, 0, 0],
                    backgroundColor: 'rgba(102, 126, 234, 0.2)',
                    borderColor: this.colors.primary,
                    borderWidth: 3,
                    pointBackgroundColor: this.colors.primary,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: this.colors.primary,
                    pointRadius: 6,
                    pointHoverRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        cornerRadius: 8,
                        callbacks: {
                            label: (context) => `Ê≠£Á≠îÁéá: ${context.parsed.r}%`
                        }
                    }
                },
                scales: {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        grid: {
                            color: 'rgba(102, 126, 234, 0.2)'
                        },
                        angleLines: {
                            color: 'rgba(102, 126, 234, 0.2)'
                        },
                        pointLabels: {
                            font: {
                                size: 12,
                                weight: 'bold'
                            },
                            color: '#333'
                        },
                        ticks: {
                            stepSize: 20,
                            display: false
                        }
                    }
                }
            }
        });
    },
    
    // ÊúàÈñìÊé®Áßª„Ç∞„É©„Éï
    initializeMonthlyChart() {
        const ctx = document.getElementById('monthlyChart');
        if (!ctx) return;
        
        this.charts.monthly = new Chart(ctx.getContext('2d'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Êó•Âà•Â≠¶ÁøíÈáè',
                    data: [],
                    borderColor: this.colors.primary,
                    backgroundColor: this.createGradient(ctx, this.colors.gradient.primary),
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointBackgroundColor: this.colors.primary,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 5,
                    pointHoverRadius: 7
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        cornerRadius: 8,
                        callbacks: {
                            label: (context) => `${context.parsed.y}ÂïèËß£Á≠î`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0,0,0,0.1)'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    },
    
    // Ê≠£Á≠îÁéá„Éà„É¨„É≥„Éâ„Ç∞„É©„Éï
    initializeTrendChart() {
        const ctx = document.getElementById('trendChart');
        if (!ctx) return;
        
        this.charts.trend = new Chart(ctx.getContext('2d'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Ê≠£Á≠îÁéá',
                    data: [],
                    borderColor: this.colors.success,
                    backgroundColor: this.createGradient(ctx, this.colors.gradient.success),
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointBackgroundColor: this.colors.success,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 5,
                    pointHoverRadius: 7
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        cornerRadius: 8,
                        callbacks: {
                            label: (context) => `Ê≠£Á≠îÁéá: ${context.parsed.y}%`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        grid: {
                            color: 'rgba(0,0,0,0.1)'
                        },
                        ticks: {
                            callback: (value) => value + '%'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    },
    
    // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥‰ΩúÊàê
    createGradient(ctx, colors) {
        const gradient = ctx.getContext('2d').createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, colors[0]);
        gradient.addColorStop(1, colors[1]);
        return gradient;
    },
    
    // ÂÖ®„Ç∞„É©„ÉïÊõ¥Êñ∞
    updateCharts() {
        const history = StorageModule.getHistory();
        
        this.updateWeekChart(history);
        this.updateSubjectChart(history);
        this.updateMonthlyChart(history);
        this.updateTrendChart(history);
        
        console.log('üìä „Ç∞„É©„Éï„Éá„Éº„ÇøÊõ¥Êñ∞ÂÆå‰∫Ü');
    },
    
    // ÈÄ±Èñì„Ç∞„É©„ÉïÊõ¥Êñ∞
    updateWeekChart(history) {
        if (!this.charts.week) return;
        
        const weekData = [0, 0, 0, 0, 0, 0, 0];
        const today = new Date();
        const weekStart = new Date(today);
        weekStart.setDate(today.getDate() - today.getDay() + 1); // ÊúàÊõúÊó•„ÇíÈÄ±„ÅÆÈñãÂßã„Å®„Åô„Çã
        
        history.forEach(record => {
            const recordDate = new Date(record.date);
            if (recordDate >= weekStart) {
                const dayIndex = recordDate.getDay() === 0 ? 6 : recordDate.getDay() - 1; // Êó•ÊõúÊó•„Çí6„Å´
                weekData[dayIndex] += record.stats.total || 0;
            }
        });
        
        this.charts.week.data.datasets[0].data = weekData;
        this.charts.week.update('none'); // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁÑ°„Åó„ÅßÈ´òÈÄüÊõ¥Êñ∞
    },
    
    // ÁßëÁõÆÂà•„Ç∞„É©„ÉïÊõ¥Êñ∞
    updateSubjectChart(history) {
        if (!this.charts.subject) return;
        
        const subjectData = {
            minpou: { total: 0, correct: 0 },
            gyousei: { total: 0, correct: 0 },
            kenpou: { total: 0, correct: 0 },
            shouhou: { total: 0, correct: 0 },
            kiso: { total: 0, correct: 0 },
            ippan: { total: 0, correct: 0 }
        };
        
        history.forEach(record => {
            if (record.subject && subjectData[record.subject]) {
                subjectData[record.subject].total += record.stats.total || 0;
                subjectData[record.subject].correct += record.stats.correct || 0;
            }
        });
        
        const subjectAccuracy = Object.keys(subjectData).map(key => {
            const data = subjectData[key];
            return data.total > 0 ? Math.round((data.correct / data.total) * 100) : 0;
        });
        
        this.charts.subject.data.datasets[0].data = subjectAccuracy;
        this.charts.subject.update('none');
    },
    
    // ÊúàÈñì„Ç∞„É©„ÉïÊõ¥Êñ∞
    updateMonthlyChart(history) {
        if (!this.charts.monthly) return;
        
        const labels = [];
        const data = [];
        
        // ÈÅéÂéª30Êó•„ÅÆ„Éá„Éº„Çø„ÇíÁîüÊàê
        for (let i = 29; i >= 0; i--) {
            const date = new Date();
            date.setDate(date.getDate() - i);
            labels.push(`${date.getMonth() + 1}/${date.getDate()}`);
            
            const dayData = history.filter(record => {
                const recordDate = new Date(record.date);
                return recordDate.toDateString() === date.toDateString();
            });
            
            const dayTotal = dayData.reduce((sum, record) => sum + (record.stats.total || 0), 0);
            data.push(dayTotal);
        }
        
        this.charts.monthly.data.labels = labels;
        this.charts.monthly.data.datasets[0].data = data;
        this.charts.monthly.update('none');
    },
    
    // „Éà„É¨„É≥„Éâ„Ç∞„É©„ÉïÊõ¥Êñ∞
    updateTrendChart(history) {
        if (!this.charts.trend) return;
        
        const recentHistory = history.slice(0, 20).reverse(); // ÊúÄÊñ∞20‰ª∂„ÇíÊôÇÁ≥ªÂàóÈ†Ü„Å´
        const labels = [];
        const data = [];
        
        recentHistory.forEach((record, index) => {
            const date = new Date(record.date);
            labels.push(`${date.getMonth() + 1}/${date.getDate()}`);
            
            const accuracy = parseInt(record.stats.percentage) || 0;
            data.push(accuracy);
        });
        
        this.charts.trend.data.labels = labels;
        this.charts.trend.data.datasets[0].data = data;
        this.charts.trend.update('none');
    },
    
    // Áµ±Ë®à„Éá„Éº„ÇøË®àÁÆó
    calculateStats(history) {
        const stats = {
            totalQuestions: 0,
            totalCorrect: 0,
            totalWrong: 0,
            totalTime: 0,
            studyDays: new Set(),
            averageAccuracy: 0,
            bestAccuracy: 0,
            worstAccuracy: 100,
            subjects: {},
            weeklyTrend: [],
            monthlyTrend: []
        };
        
        history.forEach(record => {
            stats.totalQuestions += record.stats.total || 0;
            stats.totalCorrect += record.stats.correct || 0;
            stats.totalWrong += record.stats.wrong || 0;
            stats.totalTime += record.studyTime || 0;
            
            const date = new Date(record.date);
            stats.studyDays.add(date.toDateString());
            
            const accuracy = parseInt(record.stats.percentage) || 0;
            if (accuracy > stats.bestAccuracy) stats.bestAccuracy = accuracy;
            if (accuracy < stats.worstAccuracy && accuracy > 0) stats.worstAccuracy = accuracy;
            
            // ÁßëÁõÆÂà•Áµ±Ë®à
            if (record.subject) {
                if (!stats.subjects[record.subject]) {
                    stats.subjects[record.subject] = {
                        total: 0,
                        correct: 0,
                        sessions: 0,
                        timeSpent: 0
                    };
                }
                stats.subjects[record.subject].total += record.stats.total || 0;
                stats.subjects[record.subject].correct += record.stats.correct || 0;
                stats.subjects[record.subject].sessions++;
                stats.subjects[record.subject].timeSpent += record.studyTime || 0;
            }
        });
        
        stats.averageAccuracy = stats.totalQuestions > 0 ? 
            Math.round((stats.totalCorrect / stats.totalQuestions) * 100) : 0;
        
        stats.studyDays = stats.studyDays.size;
        
        return stats;
    },
    
    // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É°„Éà„É™„ÇØ„ÇπÁîüÊàê
    generatePerformanceReport() {
        const history = StorageModule.getHistory();
        const stats = this.calculateStats(history);
        
        const report = {
            overview: {
                totalSessions: history.length,
                totalQuestions: stats.totalQuestions,
                averageAccuracy: stats.averageAccuracy,
                totalStudyTime: stats.totalTime,
                studyDays: stats.studyDays
            },
            performance: {
                bestDay: this.findBestPerformanceDay(history),
                improvementTrend: this.calculateImprovementTrend(history),
                consistencyScore: this.calculateConsistencyScore(history),
                weeklyGoalProgress: this.calculateWeeklyProgress(history)
            },
            subjects: this.analyzeSubjectPerformance(stats.subjects),
            recommendations: this.generateRecommendations(stats)
        };
        
        return report;
    },
    
    // ÊúÄÈ´ò„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÅÆÊó•„ÇíÁâπÂÆö
    findBestPerformanceDay(history) {
        let bestDay = null;
        let bestScore = 0;
        
        history.forEach(record => {
            const accuracy = parseInt(record.stats.percentage) || 0;
            const volume = record.stats.total || 0;
            const score = accuracy * (volume / 10); // Ê≠£Á≠îÁéá √ó ÂïèÈ°åÊï∞Èáç„Åø
            
            if (score > bestScore) {
                bestScore = score;
                bestDay = {
                    date: record.date,
                    accuracy: accuracy,
                    questions: volume,
                    subject: record.subject,
                    score: Math.round(score)
                };
            }
        });
        
        return bestDay;
    },
    
    // ÊîπÂñÑ„Éà„É¨„É≥„ÉâË®àÁÆó
    calculateImprovementTrend(history) {
        if (history.length < 5) return { trend: 'insufficient_data', change: 0 };
        
        const recent = history.slice(0, 5); // ÊúÄÊñ∞5‰ª∂
        const older = history.slice(5, 10); // „Åù„ÅÆÂâç„ÅÆ5‰ª∂
        
        const recentAvg = recent.reduce((sum, r) => sum + (parseInt(r.stats.percentage) || 0), 0) / recent.length;
        const olderAvg = older.reduce((sum, r) => sum + (parseInt(r.stats.percentage) || 0), 0) / older.length;
        
        const change = recentAvg - olderAvg;
        
        return {
            trend: change > 5 ? 'improving' : change < -5 ? 'declining' : 'stable',
            change: Math.round(change),
            recentAverage: Math.round(recentAvg),
            previousAverage: Math.round(olderAvg)
        };
    },
    
    // Â≠¶Áøí‰∏ÄË≤´ÊÄß„Çπ„Ç≥„Ç¢Ë®àÁÆó
    calculateConsistencyScore(history) {
        if (history.length < 7) return 0;
        
        const last7Days = [];
        const today = new Date();
        
        for (let i = 6; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            
            const dayRecords = history.filter(record => {
                const recordDate = new Date(record.date);
                return recordDate.toDateString() === date.toDateString();
            });
            
            last7Days.push(dayRecords.length > 0);
        }
        
        const studiedDays = last7Days.filter(Boolean).length;
        return Math.round((studiedDays / 7) * 100);
    },
    
    // ÈÄ±ÈñìÁõÆÊ®ôÈÄ≤ÊçóË®àÁÆó
    calculateWeeklyProgress(history) {
        const weeklyGoal = 500; // ÈÄ±500Âïè„ÅÆÁõÆÊ®ô
        const today = new Date();
        const weekStart = new Date(today);
        weekStart.setDate(today.getDate() - today.getDay() + 1);
        
        const thisWeekRecords = history.filter(record => {
            const recordDate = new Date(record.date);
            return recordDate >= weekStart;
        });
        
        const weeklyTotal = thisWeekRecords.reduce((sum, record) => sum + (record.stats.total || 0), 0);
        const progress = Math.round((weeklyTotal / weeklyGoal) * 100);
        
        return {
            current: weeklyTotal,
            goal: weeklyGoal,
            progress: Math.min(progress, 100),
            remaining: Math.max(weeklyGoal - weeklyTotal, 0),
            daysLeft: 7 - today.getDay()
        };
    },
    
    // ÁßëÁõÆÂà•„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂàÜÊûê
    analyzeSubjectPerformance(subjects) {
        const subjectNames = {
            minpou: 'Ê∞ëÊ≥ï',
            gyousei: 'Ë°åÊîøÊ≥ï',
            kenpou: 'ÊÜ≤Ê≥ï',
            shouhou: 'ÂïÜÊ≥ï',
            kiso: 'Âü∫Á§éÊ≥ïÂ≠¶',
            ippan: '‰∏ÄËà¨Áü•Ë≠ò'
        };
        
        const analysis = Object.keys(subjects).map(key => {
            const data = subjects[key];
            const accuracy = data.total > 0 ? Math.round((data.correct / data.total) * 100) : 0;
            
            return {
                subject: key,
                name: subjectNames[key],
                accuracy: accuracy,
                totalQuestions: data.total,
                sessions: data.sessions,
                averageQuestionsPerSession: data.sessions > 0 ? Math.round(data.total / data.sessions) : 0,
                timeSpent: data.timeSpent,
                efficiency: data.timeSpent > 0 ? Math.round(data.total / (data.timeSpent / 60)) : 0 // Âïè/ÂàÜ
            };
        }).sort((a, b) => b.accuracy - a.accuracy);
        
        return analysis;
    },
    
    // Êé®Â•®‰∫ãÈ†ÖÁîüÊàê
    generateRecommendations(stats) {
        const recommendations = [];
        
        // Ê≠£Á≠îÁéá„Åå‰Ωé„ÅÑÁßëÁõÆ„Å∏„ÅÆÊé®Â•®
        const weakSubjects = Object.keys(stats.subjects).filter(key => {
            const data = stats.subjects[key];
            const accuracy = data.total > 0 ? (data.correct / data.total) * 100 : 0;
            return accuracy < 70 && data.total > 10;
        });
        
        if (weakSubjects.length > 0) {
            recommendations.push({
                type: 'weak_subject',
                priority: 'high',
                message: `${weakSubjects.length}ÁßëÁõÆ„ÅßÊ≠£Á≠îÁéá70%Êú™Ê∫Ä„Åß„Åô„ÄÇÈáçÁÇπÁöÑ„Å´Â≠¶Áøí„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`,
                subjects: weakSubjects
            });
        }
        
        // Â≠¶ÁøíÈ†ªÂ∫¶„Å∏„ÅÆÊé®Â•®
        if (stats.studyDays < 5) {
            recommendations.push({
                type: 'consistency',
                priority: 'medium',
                message: 'Â≠¶Áøí„ÅÆÁ∂ôÁ∂öÊÄß„ÇíÈ´ò„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇÊØéÊó•Â∞ë„Åó„Åö„Å§„Åß„ÇÇÂ≠¶Áøí„Åô„Çã„Åì„Å®„ÅåÈáçË¶Å„Åß„Åô„ÄÇ'
            });
        }
        
        // Â≠¶ÁøíÈáè„Å∏„ÅÆÊé®Â•®
        const avgQuestionsPerDay = stats.studyDays > 0 ? stats.totalQuestions / stats.studyDays : 0;
        if (avgQuestionsPerDay < 50) {
            recommendations.push({
                type: 'volume',
                priority: 'medium',
                message: '1Êó•„ÅÇ„Åü„Çä„ÅÆÂ≠¶ÁøíÈáè„ÇíÂ¢ó„ÇÑ„Åô„Åì„Å®„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÁõÆÊ®ôÔºö50Âïè/Êó•'
            });
        }
        
        return recommendations;
    },
    
    // „ÉÅ„É£„Éº„ÉàÁ†¥Ê£Ñ
    destroyCharts() {
        Object.values(this.charts).forEach(chart => {
            if (chart) {
                chart.destroy();
            }
        });
        this.charts = {};
    }
};

// ===== „Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞ÔºàÂæåÊñπ‰∫íÊèõÊÄßÔºâ =====
function updateCharts() {
    ChartsModule.updateCharts();
}

// ===== ÂàùÊúüÂåñ =====
document.addEventListener('DOMContentLoaded', function() {
    // Chart.js„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„Åã„ÇâÂàùÊúüÂåñ
    if (typeof Chart !== 'undefined') {
        ChartsModule.initialize();
    } else {
        console.warn('üìä Chart.js„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
    }
});
